{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useState } from 'react';\nconst useManualPencilMarking = (userAnswers, generatedPuzzle) => {\n  _s();\n  const [manualPencilMarks, setManualPencilMarks] = useState(Array.from({\n    length: 9\n  }, () => Array.from({\n    length: 9\n  }, () => [])));\n  const [manualPencilMode, setManualPencilMode] = useState(false);\n  const [activeCell, setActiveCell] = useState(null);\n  const [manualPencilColors, setManualPencilColors] = useState(Array.from({\n    length: 9\n  }, () => Array.from({\n    length: 9\n  }, () => '')));\n  const [selectedColor, setSelectedColor] = useState('#11C2F2');\n  const handlePencilMarksChange = (e, rowIndex, colIndex) => {\n    const {\n      value\n    } = e.target;\n    const isUserCell = userAnswers[rowIndex][colIndex] !== '';\n    const isGeneratedCell = generatedPuzzle[rowIndex][colIndex] !== '';\n    if (activeCell !== null && manualPencilMode && !isUserCell && !isGeneratedCell) {\n      const newManualPencilMarks = [...manualPencilMarks];\n      const newManualPencilColors = [...manualPencilColors];\n\n      // Parse the input value and filter out non-numeric characters\n      const newMarks = value.split('').filter(char => /\\d/.test(char)).map(mark => parseInt(mark, 10));\n\n      // Update the manual pencil marks for the clicked cell\n      newManualPencilMarks[rowIndex][colIndex] = newMarks;\n\n      // Set the color for the clicked cell using the selected color\n      newManualPencilColors[rowIndex][colIndex] = selectedColor;\n      setManualPencilColors(newManualPencilColors);\n\n      // Update the state with the new manual pencil marks\n      setManualPencilMarks(newManualPencilMarks);\n\n      // Log the manual pencil marks for the clicked cell\n      console.log(`Manual Pencil Marks for Cell [${rowIndex}][${colIndex}]:`, newMarks);\n    }\n  };\n  const applyColorToCell = (rowIndex, colIndex) => {\n    if (manualPencilColors[rowIndex] && manualPencilColors[rowIndex][colIndex]) {\n      // Check if the index exists\n      const newManualPencilColors = [...manualPencilColors];\n      newManualPencilColors[rowIndex][colIndex] = selectedColor;\n      setManualPencilColors(newManualPencilColors);\n    }\n  };\n  return {\n    manualPencilMarks,\n    setManualPencilMarks,\n    manualPencilMode,\n    setManualPencilMode,\n    activeCell,\n    setActiveCell,\n    handlePencilMarksChange,\n    applyColorToCell,\n    selectedColor,\n    setSelectedColor,\n    manualPencilColors\n  };\n};\n_s(useManualPencilMarking, \"DJucn/mKDq/tKSG5WaduG61mIGw=\");\nexport default useManualPencilMarking;","map":{"version":3,"names":["React","useState","useManualPencilMarking","userAnswers","generatedPuzzle","_s","manualPencilMarks","setManualPencilMarks","Array","from","length","manualPencilMode","setManualPencilMode","activeCell","setActiveCell","manualPencilColors","setManualPencilColors","selectedColor","setSelectedColor","handlePencilMarksChange","e","rowIndex","colIndex","value","target","isUserCell","isGeneratedCell","newManualPencilMarks","newManualPencilColors","newMarks","split","filter","char","test","map","mark","parseInt","console","log","applyColorToCell"],"sources":["/Users/kumarprasad/Desktop/GitHub/ravi-sudoku project/src/Pencil-Marking/ManualPencilMarking.js"],"sourcesContent":["import React, { useState } from 'react';\n\nconst useManualPencilMarking = (userAnswers, generatedPuzzle) => {  \nconst [manualPencilMarks, setManualPencilMarks] = useState(\n    Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => []))\n  );\n  const [manualPencilMode, setManualPencilMode] = useState(false);\n  const [activeCell, setActiveCell] = useState(null);\n\n  const [manualPencilColors, setManualPencilColors] = useState(Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => '')));\n  const [selectedColor, setSelectedColor] = useState('#11C2F2'); \n\n  const handlePencilMarksChange = (e, rowIndex, colIndex) => {\n    const { value } = e.target;\n    const isUserCell = userAnswers[rowIndex][colIndex] !== '';\n    const isGeneratedCell = generatedPuzzle[rowIndex][colIndex] !== '';\n  \n    if (activeCell !== null && manualPencilMode && !isUserCell && !isGeneratedCell) {\n      const newManualPencilMarks = [...manualPencilMarks];\n      const newManualPencilColors = [...manualPencilColors]; \n  \n      // Parse the input value and filter out non-numeric characters\n      const newMarks = value.split('').filter(char => /\\d/.test(char)).map(mark => parseInt(mark, 10));\n  \n      // Update the manual pencil marks for the clicked cell\n      newManualPencilMarks[rowIndex][colIndex] = newMarks;\n  \n      // Set the color for the clicked cell using the selected color\n      newManualPencilColors[rowIndex][colIndex] = selectedColor;\n      setManualPencilColors(newManualPencilColors);\n  \n      // Update the state with the new manual pencil marks\n      setManualPencilMarks(newManualPencilMarks);\n  \n      // Log the manual pencil marks for the clicked cell\n      console.log(`Manual Pencil Marks for Cell [${rowIndex}][${colIndex}]:`, newMarks);\n    }\n  };  \n\n  const applyColorToCell = (rowIndex, colIndex) => {\n    if (manualPencilColors[rowIndex] && manualPencilColors[rowIndex][colIndex]) { // Check if the index exists\n      const newManualPencilColors = [...manualPencilColors];\n      newManualPencilColors[rowIndex][colIndex] = selectedColor;\n      setManualPencilColors(newManualPencilColors);\n    }\n  };\n\n  return {\n    manualPencilMarks,\n    setManualPencilMarks,\n    manualPencilMode,\n    setManualPencilMode,\n    activeCell,\n    setActiveCell,\n    handlePencilMarksChange,\n    applyColorToCell,\n    selectedColor,\n    setSelectedColor,\n    manualPencilColors \n  };\n};\n\nexport default useManualPencilMarking;\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,QAAQ,QAAQ,OAAO;AAEvC,MAAMC,sBAAsB,GAAGA,CAACC,WAAW,EAAEC,eAAe,KAAK;EAAAC,EAAA;EACjE,MAAM,CAACC,iBAAiB,EAAEC,oBAAoB,CAAC,GAAGN,QAAQ,CACtDO,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAE;EAAE,CAAC,EAAE,MAAMF,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAE;EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,CACrE,CAAC;EACD,MAAM,CAACC,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGX,QAAQ,CAAC,KAAK,CAAC;EAC/D,MAAM,CAACY,UAAU,EAAEC,aAAa,CAAC,GAAGb,QAAQ,CAAC,IAAI,CAAC;EAElD,MAAM,CAACc,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGf,QAAQ,CAACO,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAE;EAAE,CAAC,EAAE,MAAMF,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAE;EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;EAClI,MAAM,CAACO,aAAa,EAAEC,gBAAgB,CAAC,GAAGjB,QAAQ,CAAC,SAAS,CAAC;EAE7D,MAAMkB,uBAAuB,GAAGA,CAACC,CAAC,EAAEC,QAAQ,EAAEC,QAAQ,KAAK;IACzD,MAAM;MAAEC;IAAM,CAAC,GAAGH,CAAC,CAACI,MAAM;IAC1B,MAAMC,UAAU,GAAGtB,WAAW,CAACkB,QAAQ,CAAC,CAACC,QAAQ,CAAC,KAAK,EAAE;IACzD,MAAMI,eAAe,GAAGtB,eAAe,CAACiB,QAAQ,CAAC,CAACC,QAAQ,CAAC,KAAK,EAAE;IAElE,IAAIT,UAAU,KAAK,IAAI,IAAIF,gBAAgB,IAAI,CAACc,UAAU,IAAI,CAACC,eAAe,EAAE;MAC9E,MAAMC,oBAAoB,GAAG,CAAC,GAAGrB,iBAAiB,CAAC;MACnD,MAAMsB,qBAAqB,GAAG,CAAC,GAAGb,kBAAkB,CAAC;;MAErD;MACA,MAAMc,QAAQ,GAAGN,KAAK,CAACO,KAAK,CAAC,EAAE,CAAC,CAACC,MAAM,CAACC,IAAI,IAAI,IAAI,CAACC,IAAI,CAACD,IAAI,CAAC,CAAC,CAACE,GAAG,CAACC,IAAI,IAAIC,QAAQ,CAACD,IAAI,EAAE,EAAE,CAAC,CAAC;;MAEhG;MACAR,oBAAoB,CAACN,QAAQ,CAAC,CAACC,QAAQ,CAAC,GAAGO,QAAQ;;MAEnD;MACAD,qBAAqB,CAACP,QAAQ,CAAC,CAACC,QAAQ,CAAC,GAAGL,aAAa;MACzDD,qBAAqB,CAACY,qBAAqB,CAAC;;MAE5C;MACArB,oBAAoB,CAACoB,oBAAoB,CAAC;;MAE1C;MACAU,OAAO,CAACC,GAAG,CAAE,iCAAgCjB,QAAS,KAAIC,QAAS,IAAG,EAAEO,QAAQ,CAAC;IACnF;EACF,CAAC;EAED,MAAMU,gBAAgB,GAAGA,CAAClB,QAAQ,EAAEC,QAAQ,KAAK;IAC/C,IAAIP,kBAAkB,CAACM,QAAQ,CAAC,IAAIN,kBAAkB,CAACM,QAAQ,CAAC,CAACC,QAAQ,CAAC,EAAE;MAAE;MAC5E,MAAMM,qBAAqB,GAAG,CAAC,GAAGb,kBAAkB,CAAC;MACrDa,qBAAqB,CAACP,QAAQ,CAAC,CAACC,QAAQ,CAAC,GAAGL,aAAa;MACzDD,qBAAqB,CAACY,qBAAqB,CAAC;IAC9C;EACF,CAAC;EAED,OAAO;IACLtB,iBAAiB;IACjBC,oBAAoB;IACpBI,gBAAgB;IAChBC,mBAAmB;IACnBC,UAAU;IACVC,aAAa;IACbK,uBAAuB;IACvBoB,gBAAgB;IAChBtB,aAAa;IACbC,gBAAgB;IAChBH;EACF,CAAC;AACH,CAAC;AAACV,EAAA,CA1DIH,sBAAsB;AA4D5B,eAAeA,sBAAsB"},"metadata":{},"sourceType":"module","externalDependencies":[]}