{"ast":null,"code":"// PuzzleGeneration.js\nimport { generatePencilMarks, updatePencilMarks, usePencilMarks } from './Pencil-Marking/PencilMarking';\n\n// Function to generate a random Sudoku puzzle\nexport function generateRandomSudokuPuzzle() {\n  let difficulty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.7;\n  // Helper function to shuffle an array\n  const shuffleArray = arr => {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  };\n\n  // Helper function to check if a number can be placed in a cell\n  const isValidNumber = (board, row, col, num) => {\n    for (let i = 0; i < 9; i++) {\n      if (board[row][i] === num || board[i][col] === num || board[Math.floor(row / 3) * 3 + Math.floor(i / 3)][Math.floor(col / 3) * 3 + i % 3] === num) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  // Initialize an empty 9x9 Sudoku board\n  const board = Array.from({\n    length: 9\n  }, () => Array.from({\n    length: 9\n  }, () => 0));\n\n  // Helper function to fill the Sudoku board using backtracking\n  const solveSudokuBacktrack = () => {\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        if (board[row][col] === 0) {\n          const nums = shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n          for (const num of nums) {\n            if (isValidNumber(board, row, col, num)) {\n              board[row][col] = num;\n              if (solveSudokuBacktrack()) {\n                return true;\n              }\n              board[row][col] = 0;\n            }\n          }\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  // Start the backtracking to fill the Sudoku board\n  solveSudokuBacktrack();\n\n  // Helper function to remove numbers from the solved Sudoku board based on difficulty\n  const removeNumbersBasedOnDifficulty = (board, difficulty) => {\n    const cellsCount = 81;\n    const cellsToRemove = Math.floor(cellsCount * difficulty);\n    const cellsIndices = shuffleArray(Array.from({\n      length: cellsCount\n    }, (_, index) => index));\n    for (let i = 0; i < cellsToRemove; i++) {\n      const cellIndex = cellsIndices[i];\n      const row = Math.floor(cellIndex / 9);\n      const col = cellIndex % 9;\n      const temp = board[row][col];\n      board[row][col] = 0;\n\n      // Check if the board is still solvable with a unique solution\n      const clonedBoard = JSON.parse(JSON.stringify(board));\n      if (isSolvable(clonedBoard) !== 1) {\n        board[row][col] = temp; // Revert the removal if the board becomes unsolvable\n      }\n    }\n  };\n\n  // Helper function to check if the board is solvable with a unique solution\n\n  const isSolvable = board => {\n    const solveSudokuBacktrack = () => {\n      for (let row = 0; row < 9; row++) {\n        for (let col = 0; col < 9; col++) {\n          if (board[row][col] === 0) {\n            for (let num = 1; num <= 9; num++) {\n              if (isValidNumber(board, row, col, num)) {\n                board[row][col] = num;\n                if (solveSudokuBacktrack()) {\n                  return true;\n                }\n                board[row][col] = 0;\n              }\n            }\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    const isValidNumber = (board, row, col, num) => {\n      for (let i = 0; i < 9; i++) {\n        if (board[row][i] === num || board[i][col] === num || board[Math.floor(row / 3) * 3 + Math.floor(i / 3)][Math.floor(col / 3) * 3 + i % 3] === num) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const clonedBoard = JSON.parse(JSON.stringify(board));\n    return solveSudokuBacktrack(clonedBoard) ? 1 : 0;\n  };\n\n  // Remove numbers from the solved Sudoku board based on difficulty\n  removeNumbersBasedOnDifficulty(board, difficulty);\n\n  // Convert the board to a string representation\n  return board.map(row => row.join('')).join('');\n}","map":{"version":3,"names":["generatePencilMarks","updatePencilMarks","usePencilMarks","generateRandomSudokuPuzzle","difficulty","arguments","length","undefined","shuffleArray","arr","i","j","Math","floor","random","isValidNumber","board","row","col","num","Array","from","solveSudokuBacktrack","nums","removeNumbersBasedOnDifficulty","cellsCount","cellsToRemove","cellsIndices","_","index","cellIndex","temp","clonedBoard","JSON","parse","stringify","isSolvable","map","join"],"sources":["/Users/kumarprasad/Desktop/GitHub/ravi-sudoku project/src/PuzzleGeneration.js"],"sourcesContent":["// PuzzleGeneration.js\nimport { generatePencilMarks, updatePencilMarks, usePencilMarks } from './Pencil-Marking/PencilMarking';\n\n// Function to generate a random Sudoku puzzle\nexport function generateRandomSudokuPuzzle(difficulty = 0.7) {\n  // Helper function to shuffle an array\n  const shuffleArray = (arr) => {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  };\n\n  // Helper function to check if a number can be placed in a cell\n  const isValidNumber = (board, row, col, num) => {\n    for (let i = 0; i < 9; i++) {\n      if (\n        board[row][i] === num ||\n        board[i][col] === num ||\n        board[Math.floor(row / 3) * 3 + Math.floor(i / 3)][Math.floor(col / 3) * 3 + (i % 3)] === num\n      ) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  // Initialize an empty 9x9 Sudoku board\n  const board = Array.from({ length: 9 }, () => Array.from({ length: 9 }, () => 0));\n\n  // Helper function to fill the Sudoku board using backtracking\n  const solveSudokuBacktrack = () => {\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        if (board[row][col] === 0) {\n          const nums = shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n          for (const num of nums) {\n            if (isValidNumber(board, row, col, num)) {\n              board[row][col] = num;\n              if (solveSudokuBacktrack()) {\n                return true;\n              }\n              board[row][col] = 0;\n            }\n          }\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  // Start the backtracking to fill the Sudoku board\n  solveSudokuBacktrack();\n\n  // Helper function to remove numbers from the solved Sudoku board based on difficulty\n  const removeNumbersBasedOnDifficulty = (board, difficulty) => {\n    const cellsCount = 81;\n    const cellsToRemove = Math.floor(cellsCount * difficulty);\n    const cellsIndices = shuffleArray(Array.from({ length: cellsCount }, (_, index) => index));\n    \n    for (let i = 0; i < cellsToRemove; i++) {\n      const cellIndex = cellsIndices[i];\n      const row = Math.floor(cellIndex / 9);\n      const col = cellIndex % 9;\n      const temp = board[row][col];\n      board[row][col] = 0;\n\n      // Check if the board is still solvable with a unique solution\n      const clonedBoard = JSON.parse(JSON.stringify(board));\n      if (isSolvable(clonedBoard) !== 1) {\n        board[row][col] = temp; // Revert the removal if the board becomes unsolvable\n      }\n    }\n  };\n\n  // Helper function to check if the board is solvable with a unique solution\n  \n  const isSolvable = (board) => {\n  const solveSudokuBacktrack = () => {\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        if (board[row][col] === 0) {\n          for (let num = 1; num <= 9; num++) {\n            if (isValidNumber(board, row, col, num)) {\n              board[row][col] = num;\n              if (solveSudokuBacktrack()) {\n                return true;\n              }\n              board[row][col] = 0;\n            }\n          }\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  const isValidNumber = (board, row, col, num) => {\n    for (let i = 0; i < 9; i++) {\n      if (\n        board[row][i] === num ||\n        board[i][col] === num ||\n        board[Math.floor(row / 3) * 3 + Math.floor(i / 3)][Math.floor(col / 3) * 3 + (i % 3)] === num\n      ) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  const clonedBoard = JSON.parse(JSON.stringify(board));\n  return solveSudokuBacktrack(clonedBoard) ? 1 : 0;\n};\n\n  // Remove numbers from the solved Sudoku board based on difficulty\n  removeNumbersBasedOnDifficulty(board, difficulty);\n\n  // Convert the board to a string representation\n  return board.map((row) => row.join('')).join('');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}